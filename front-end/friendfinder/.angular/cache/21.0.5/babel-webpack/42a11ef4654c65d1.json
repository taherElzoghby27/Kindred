{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Component, ChangeDetectionStrategy, ViewEncapsulation, inject, NgZone, RendererFactory2, Injectable, ElementRef, EventEmitter, Directive, Output, Renderer2, DOCUMENT, booleanAttribute, Input, NgModule } from '@angular/core';\nimport { EMPTY, Subject } from 'rxjs';\nimport { Platform } from './_platform-chunk.mjs';\nimport { _CdkPrivateStyleLoader } from './_style-loader-chunk.mjs';\nimport { coerceElement, coerceNumberProperty } from './_element-chunk.mjs';\nimport { auditTime } from 'rxjs/operators';\nimport '@angular/common';\nlet _CdkTextFieldStyleLoader = /*#__PURE__*/(() => {\n  class _CdkTextFieldStyleLoader {\n    static ɵfac = function _CdkTextFieldStyleLoader_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || _CdkTextFieldStyleLoader)();\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: _CdkTextFieldStyleLoader,\n      selectors: [[\"ng-component\"]],\n      hostAttrs: [\"cdk-text-field-style-loader\", \"\"],\n      decls: 0,\n      vars: 0,\n      template: function _CdkTextFieldStyleLoader_Template(rf, ctx) {},\n      styles: [\"textarea.cdk-textarea-autosize{resize:none}textarea.cdk-textarea-autosize-measuring{padding:2px 0 !important;box-sizing:content-box !important;height:auto !important;overflow:hidden !important}textarea.cdk-textarea-autosize-measuring-firefox{padding:2px 0 !important;box-sizing:content-box !important;height:0 !important}@keyframes cdk-text-field-autofill-start{/*!*/}@keyframes cdk-text-field-autofill-end{/*!*/}.cdk-text-field-autofill-monitored:-webkit-autofill{animation:cdk-text-field-autofill-start 0s 1ms}.cdk-text-field-autofill-monitored:not(:-webkit-autofill){animation:cdk-text-field-autofill-end 0s 1ms}\\n\"],\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return _CdkTextFieldStyleLoader;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst listenerOptions = {\n  passive: true\n};\nlet AutofillMonitor = /*#__PURE__*/(() => {\n  class AutofillMonitor {\n    _platform = inject(Platform);\n    _ngZone = inject(NgZone);\n    _renderer = inject(RendererFactory2).createRenderer(null, null);\n    _styleLoader = inject(_CdkPrivateStyleLoader);\n    _monitoredElements = new Map();\n    constructor() {}\n    monitor(elementOrRef) {\n      if (!this._platform.isBrowser) {\n        return EMPTY;\n      }\n      this._styleLoader.load(_CdkTextFieldStyleLoader);\n      const element = coerceElement(elementOrRef);\n      const info = this._monitoredElements.get(element);\n      if (info) {\n        return info.subject;\n      }\n      const subject = new Subject();\n      const cssClass = 'cdk-text-field-autofilled';\n      const listener = event => {\n        if (event.animationName === 'cdk-text-field-autofill-start' && !element.classList.contains(cssClass)) {\n          element.classList.add(cssClass);\n          this._ngZone.run(() => subject.next({\n            target: event.target,\n            isAutofilled: true\n          }));\n        } else if (event.animationName === 'cdk-text-field-autofill-end' && element.classList.contains(cssClass)) {\n          element.classList.remove(cssClass);\n          this._ngZone.run(() => subject.next({\n            target: event.target,\n            isAutofilled: false\n          }));\n        }\n      };\n      const unlisten = this._ngZone.runOutsideAngular(() => {\n        element.classList.add('cdk-text-field-autofill-monitored');\n        return this._renderer.listen(element, 'animationstart', listener, listenerOptions);\n      });\n      this._monitoredElements.set(element, {\n        subject,\n        unlisten\n      });\n      return subject;\n    }\n    stopMonitoring(elementOrRef) {\n      const element = coerceElement(elementOrRef);\n      const info = this._monitoredElements.get(element);\n      if (info) {\n        info.unlisten();\n        info.subject.complete();\n        element.classList.remove('cdk-text-field-autofill-monitored');\n        element.classList.remove('cdk-text-field-autofilled');\n        this._monitoredElements.delete(element);\n      }\n    }\n    ngOnDestroy() {\n      this._monitoredElements.forEach((_info, element) => this.stopMonitoring(element));\n    }\n    static ɵfac = function AutofillMonitor_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || AutofillMonitor)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: AutofillMonitor,\n      factory: AutofillMonitor.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return AutofillMonitor;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CdkAutofill = /*#__PURE__*/(() => {\n  class CdkAutofill {\n    _elementRef = inject(ElementRef);\n    _autofillMonitor = inject(AutofillMonitor);\n    cdkAutofill = new EventEmitter();\n    constructor() {}\n    ngOnInit() {\n      this._autofillMonitor.monitor(this._elementRef).subscribe(event => this.cdkAutofill.emit(event));\n    }\n    ngOnDestroy() {\n      this._autofillMonitor.stopMonitoring(this._elementRef);\n    }\n    static ɵfac = function CdkAutofill_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkAutofill)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkAutofill,\n      selectors: [[\"\", \"cdkAutofill\", \"\"]],\n      outputs: {\n        cdkAutofill: \"cdkAutofill\"\n      }\n    });\n  }\n  return CdkAutofill;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CdkTextareaAutosize = /*#__PURE__*/(() => {\n  class CdkTextareaAutosize {\n    _elementRef = inject(ElementRef);\n    _platform = inject(Platform);\n    _ngZone = inject(NgZone);\n    _renderer = inject(Renderer2);\n    _resizeEvents = new Subject();\n    _previousValue;\n    _initialHeight;\n    _destroyed = new Subject();\n    _listenerCleanups;\n    _minRows;\n    _maxRows;\n    _enabled = true;\n    _previousMinRows = -1;\n    _textareaElement;\n    get minRows() {\n      return this._minRows;\n    }\n    set minRows(value) {\n      this._minRows = coerceNumberProperty(value);\n      this._setMinHeight();\n    }\n    get maxRows() {\n      return this._maxRows;\n    }\n    set maxRows(value) {\n      this._maxRows = coerceNumberProperty(value);\n      this._setMaxHeight();\n    }\n    get enabled() {\n      return this._enabled;\n    }\n    set enabled(value) {\n      if (this._enabled !== value) {\n        (this._enabled = value) ? this.resizeToFitContent(true) : this.reset();\n      }\n    }\n    get placeholder() {\n      return this._textareaElement.placeholder;\n    }\n    set placeholder(value) {\n      this._cachedPlaceholderHeight = undefined;\n      if (value) {\n        this._textareaElement.setAttribute('placeholder', value);\n      } else {\n        this._textareaElement.removeAttribute('placeholder');\n      }\n      this._cacheTextareaPlaceholderHeight();\n    }\n    _cachedLineHeight;\n    _cachedPlaceholderHeight;\n    _document = inject(DOCUMENT);\n    _hasFocus;\n    _isViewInited = false;\n    constructor() {\n      const styleLoader = inject(_CdkPrivateStyleLoader);\n      styleLoader.load(_CdkTextFieldStyleLoader);\n      this._textareaElement = this._elementRef.nativeElement;\n    }\n    _setMinHeight() {\n      const minHeight = this.minRows && this._cachedLineHeight ? `${this.minRows * this._cachedLineHeight}px` : null;\n      if (minHeight) {\n        this._textareaElement.style.minHeight = minHeight;\n      }\n    }\n    _setMaxHeight() {\n      const maxHeight = this.maxRows && this._cachedLineHeight ? `${this.maxRows * this._cachedLineHeight}px` : null;\n      if (maxHeight) {\n        this._textareaElement.style.maxHeight = maxHeight;\n      }\n    }\n    ngAfterViewInit() {\n      if (this._platform.isBrowser) {\n        this._initialHeight = this._textareaElement.style.height;\n        this.resizeToFitContent();\n        this._ngZone.runOutsideAngular(() => {\n          this._listenerCleanups = [this._renderer.listen('window', 'resize', () => this._resizeEvents.next()), this._renderer.listen(this._textareaElement, 'focus', this._handleFocusEvent), this._renderer.listen(this._textareaElement, 'blur', this._handleFocusEvent)];\n          this._resizeEvents.pipe(auditTime(16)).subscribe(() => {\n            this._cachedLineHeight = this._cachedPlaceholderHeight = undefined;\n            this.resizeToFitContent(true);\n          });\n        });\n        this._isViewInited = true;\n        this.resizeToFitContent(true);\n      }\n    }\n    ngOnDestroy() {\n      this._listenerCleanups?.forEach(cleanup => cleanup());\n      this._resizeEvents.complete();\n      this._destroyed.next();\n      this._destroyed.complete();\n    }\n    _cacheTextareaLineHeight() {\n      if (this._cachedLineHeight) {\n        return;\n      }\n      const textareaClone = this._textareaElement.cloneNode(false);\n      const cloneStyles = textareaClone.style;\n      textareaClone.rows = 1;\n      cloneStyles.position = 'absolute';\n      cloneStyles.visibility = 'hidden';\n      cloneStyles.border = 'none';\n      cloneStyles.padding = '0';\n      cloneStyles.height = '';\n      cloneStyles.minHeight = '';\n      cloneStyles.maxHeight = '';\n      cloneStyles.top = cloneStyles.bottom = cloneStyles.left = cloneStyles.right = 'auto';\n      cloneStyles.overflow = 'hidden';\n      this._textareaElement.parentNode.appendChild(textareaClone);\n      this._cachedLineHeight = textareaClone.clientHeight;\n      textareaClone.remove();\n      this._setMinHeight();\n      this._setMaxHeight();\n    }\n    _measureScrollHeight() {\n      const element = this._textareaElement;\n      const previousMargin = element.style.marginBottom || '';\n      const isFirefox = this._platform.FIREFOX;\n      const needsMarginFiller = isFirefox && this._hasFocus;\n      const measuringClass = isFirefox ? 'cdk-textarea-autosize-measuring-firefox' : 'cdk-textarea-autosize-measuring';\n      if (needsMarginFiller) {\n        element.style.marginBottom = `${element.clientHeight}px`;\n      }\n      element.classList.add(measuringClass);\n      const scrollHeight = element.scrollHeight - 4;\n      element.classList.remove(measuringClass);\n      if (needsMarginFiller) {\n        element.style.marginBottom = previousMargin;\n      }\n      return scrollHeight;\n    }\n    _cacheTextareaPlaceholderHeight() {\n      if (!this._isViewInited || this._cachedPlaceholderHeight != undefined) {\n        return;\n      }\n      if (!this.placeholder) {\n        this._cachedPlaceholderHeight = 0;\n        return;\n      }\n      const value = this._textareaElement.value;\n      this._textareaElement.value = this._textareaElement.placeholder;\n      this._cachedPlaceholderHeight = this._measureScrollHeight();\n      this._textareaElement.value = value;\n    }\n    _handleFocusEvent = event => {\n      this._hasFocus = event.type === 'focus';\n    };\n    ngDoCheck() {\n      if (this._platform.isBrowser) {\n        this.resizeToFitContent();\n      }\n    }\n    resizeToFitContent(force = false) {\n      if (!this._enabled) {\n        return;\n      }\n      this._cacheTextareaLineHeight();\n      this._cacheTextareaPlaceholderHeight();\n      if (!this._cachedLineHeight) {\n        return;\n      }\n      const textarea = this._elementRef.nativeElement;\n      const value = textarea.value;\n      if (!force && this._minRows === this._previousMinRows && value === this._previousValue) {\n        return;\n      }\n      const scrollHeight = this._measureScrollHeight();\n      const height = Math.max(scrollHeight, this._cachedPlaceholderHeight || 0);\n      textarea.style.height = `${height}px`;\n      this._ngZone.runOutsideAngular(() => {\n        if (typeof requestAnimationFrame !== 'undefined') {\n          requestAnimationFrame(() => this._scrollToCaretPosition(textarea));\n        } else {\n          setTimeout(() => this._scrollToCaretPosition(textarea));\n        }\n      });\n      this._previousValue = value;\n      this._previousMinRows = this._minRows;\n    }\n    reset() {\n      if (this._initialHeight !== undefined) {\n        this._textareaElement.style.height = this._initialHeight;\n      }\n    }\n    _noopInputHandler() {}\n    _scrollToCaretPosition(textarea) {\n      const {\n        selectionStart,\n        selectionEnd\n      } = textarea;\n      if (!this._destroyed.isStopped && this._hasFocus) {\n        textarea.setSelectionRange(selectionStart, selectionEnd);\n      }\n    }\n    static ɵfac = function CdkTextareaAutosize_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkTextareaAutosize)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: CdkTextareaAutosize,\n      selectors: [[\"textarea\", \"cdkTextareaAutosize\", \"\"]],\n      hostAttrs: [\"rows\", \"1\", 1, \"cdk-textarea-autosize\"],\n      hostBindings: function CdkTextareaAutosize_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"input\", function CdkTextareaAutosize_input_HostBindingHandler() {\n            return ctx._noopInputHandler();\n          });\n        }\n      },\n      inputs: {\n        minRows: [0, \"cdkAutosizeMinRows\", \"minRows\"],\n        maxRows: [0, \"cdkAutosizeMaxRows\", \"maxRows\"],\n        enabled: [2, \"cdkTextareaAutosize\", \"enabled\", booleanAttribute],\n        placeholder: \"placeholder\"\n      },\n      exportAs: [\"cdkTextareaAutosize\"]\n    });\n  }\n  return CdkTextareaAutosize;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TextFieldModule = /*#__PURE__*/(() => {\n  class TextFieldModule {\n    static ɵfac = function TextFieldModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || TextFieldModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: TextFieldModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  }\n  return TextFieldModule;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nexport { AutofillMonitor, CdkAutofill, CdkTextareaAutosize, TextFieldModule };\n//# sourceMappingURL=text-field.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}